// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    PAYMENT_L2_ELF, PAYMENT_L2_ID,
};
use risc0_zkvm::{default_prover, ExecutorEnv};
use rand::rngs::OsRng;
use ed25519_dalek::SigningKey;
use ed25519_dalek::{VerifyingKey};
use common::{Hash, AccountBook, EngineInput, PaymentTx, TransactionSet, BlockHeader};

// prove is slow, use dev mode for testing:
// RISC0_DEV_MODE=true cargo run --color=always --bin host --manifest-path ./host/Cargo.toml
fn main() {
    // 1 tx:  3m18.492s, with 24 core CPU
    // 5 tx: 15m31.657s
    let num_txns = 5u32;

    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let mut csprng = OsRng;
    let mut faucet_signing_key: SigningKey = SigningKey::generate(&mut csprng);
    let faucet_verifying_key: VerifyingKey = faucet_signing_key.verifying_key();

    let book = AccountBook::new(faucet_verifying_key, 1000000u128);
    let mut txns = TransactionSet::new();
    for i in 0..num_txns {
        let alice_signing_key: SigningKey = SigningKey::generate(&mut csprng);
        let alice_verifying_key: VerifyingKey = alice_signing_key.verifying_key();
        txns.add_tx(PaymentTx::new(faucet_verifying_key, alice_verifying_key, 10, i, &mut faucet_signing_key));
    }

    let mut input = EngineInput { parent: Hash::default(), account_book: book, txns: txns, sqn: 0 };
    // let input: u32 = 15 * u32::pow(2, 27) + 1;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover
        .prove(env, PAYMENT_L2_ELF)
        .unwrap();

    // Retrieving receipt journal
    let header_guest: BlockHeader = receipt.journal.decode().unwrap();

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt
        .verify(PAYMENT_L2_ID)
        .unwrap();

    // only for testing:
    // process input in host, and compare the resulting block header with the guest output header
    let header_host = input.process();
    println!("header_host : {:?}", header_host);
    println!("header_guest: {:?}", header_guest);
    println!("header_host hash : {:?}", header_host.hash());
    println!("header_guest hash: {:?}", header_guest.hash());
    println!("same header hash: {}", header_guest.hash() == header_host.hash());
}
